---
title: "HiFi Full-length ITS Analysis Report"
output:
  html_document:
    self_contained: true
output_file: "/absolute/path/to/output_dir/ITS_Pipeline_Analysis_Report.html"
params:
  config_yaml: "ITS_pipeline_inputs.yaml"
---

<div style="font-size:small; color:gray; margin-bottom:1em;">
  Report generated on: `r format(Sys.Date(), "%A, %d %B %Y")`
</div>

```{r setup, include=FALSE, echo=FALSE}
if (!require("pacman")) {
  install.packages("pacman")
  library(pacman)
}

reqlibs <- c("yaml", "tidyverse", "phyloseq", "biomformat", 
                  "knitr", "DT", "ComplexHeatmap", "viridis", 
                  "Biostrings", "pheatmap", "biomformat",
                  "grid", "cowplot",
                  "RColorBrewer")

do.call(pacman::p_load, as.list(reqlibs))

wd <- "~/work/Projects-NucleomicsCore/exp5001_SWeckx_Kinnex/07_nextITS"
opts_chunk$set(message=FALSE, 
               warning=FALSE, 
               eval=TRUE,
               echo=FALSE,
               fig.cap=".",
               fig.show="asis",
               fig.keep="high",
               cache=TRUE,
               root.dir=wd)
setwd(wd)

# Load config from YAML
config <- yaml::read_yaml(params$config_yaml)

# Source import_biom.R for custom import functions
import_biom_path <- paste(wd, "scripts/import_biom.R", sep="/")
source(import_biom_path)
```

```{r initialization, echo=FALSE}
# extract variables
forward_primer <- config$forward_primer
forward_primer_info <- config$forward_primer_info
reverse_primer <- config$reverse_primer
reverse_primer_info <- config$reverse_primer_info

otu_count_file <- paste(wd, config$otu_count_file, sep="/")
taxonomy_file <- paste(wd, config$taxonomy_file, sep="/")
sample_metadata_file <- paste(wd, config$sample_metadata_file, sep="/")
grouping_column <- config$grouping_column
classification_info_file <- paste(wd, config$classification_info_file, sep="/")
ASV_sequences <- paste(wd, config$ASV_sequences, sep="/")

# path to outputs
output_dir <- wd
```

## Classification using Naive Bayes classifier against Unite

Pacific Bioscience Kinnex data was generated at the Nucleomics Core using custom primers specific for the eukaryote ITS locus and produce HiFi data for this analysis.

The primer sequences used in this project were:

* forp `r paste(forward_primer, forward_primer_info, sep=", ")`
* revp `r paste(reverse_primer, reverse_primer_info, sep=", ")` 

The primer pair is designed to amplify fungal ITS regions broadly and inclusively, covering both Ascomycetes and Basidiomycetes, with degenerate bases for the reverse primer to capture diverse fungal groups and reduce bias (ref: Tedersoo and Lindahl, 2016, doi:10.1111/1758-2229.12438).

ITS containing amplicons were processed using the Kinnex 16S kit to produce 16mer concatemers sequenced as HiFi reads then deconcatenated and demultiplexed using pacbio software (skera and lima) and standard parameters (no size cutoff).

The raw sequencing data was analyzed using the **[NextITS pipeline](https://github.com/vmikk/NextITS)** (version: vmiks_nextits_0.8.2) and the full NextITS nextflow result folder is provided and with more information about the primary analysis results, the raw read processing and quality controls included in the pipeline.

The ASV sequences obtained from the final LULU step (OTUs_LULU.fa) and their respective counts across samples (OTU_table.txt.gz) were used to generate this report and provide initial insights into the data. 

The NextITS *OTUs_LULU.fa* sequences were classified with the Qiime2 Naive Bayes classifier against the **Unite database** (v10.0 - 2025-02-19 - fungi; fungi_99pc_2025-02-19 classifier generated using Qiime amplicon version 2025-7). The obtained taxonomy (TAX) was combined to the sample metadata information derived from the customer sample-sheet (SAMPLES), and the merged ASV count table generated by NextITS (OTU) to obtain a fully functional R phyloseq object used in this report.

The *OTUs_LULU.fa* sequences were also used to measure the distribution of ASV lengths in the data as ITS regions are quite variable in length as opposed to the rather conserved 16S region in prokaryotes.

Note: A deeper exploration of the data will be required to obtained solid results and can be initiated using the provided Phyloseq Object (physeq_object.rds and physeq_object.biom for your convenience).


```{r compute physeq, echo=FALSE}
# Read sample metadata
sample_metadata <- read_csv(sample_metadata_file, show_col_types = FALSE)

# Read OTU table
otu_table_df <- read_tsv(otu_count_file, show_col_types = FALSE)

# Read taxonomy
taxonomy_df <- read_tsv(taxonomy_file, show_col_types = FALSE)

# Prepare ASV table (rows: ASVs, columns: samples)
asv_mat <- as.matrix(otu_table_df[,-1])
rownames(asv_mat) <- otu_table_df[["OTU"]]

# Prepare taxonomy table (adapted to input header)
tax_mat <- as.data.frame(taxonomy_df[, "Taxon", drop=FALSE])
rownames(tax_mat) <- taxonomy_df[["Feature ID"]]
colnames(tax_mat) <- "Taxonomy"

# Split taxonomy string into columns for phyloseq
# This will create columns: Kingdom, Phylum, Class, Order, Family, Genus, Species, Strain
# and remove prefixes like 'g__' and underscores
tax_split <- strsplit(as.character(tax_mat$Taxonomy), ";")
max_len <- max(sapply(tax_split, length))
tax_matrix <- do.call(rbind, lapply(tax_split, function(x) {
  x <- trimws(x)
  length(x) <- max_len
  x
}))
num_ranks <- max(sapply(tax_split, length))
rank_names <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "Strain")[1:num_ranks]
colnames(tax_matrix) <- rank_names
rownames(tax_matrix) <- rownames(tax_mat)
for (i in seq_len(ncol(tax_matrix))) {
  tax_matrix[, i] <- gsub(".*__", "", tax_matrix[, i])
  tax_matrix[, i] <- gsub("_", " ", tax_matrix[, i])
}

# Extract genus from taxonomy (assumes taxonomy is semicolon separated)
tax_mat$Genus <- sapply(strsplit(as.character(tax_mat$Taxonomy), ";"), function(x) {
  if (length(x) >= 6) {
    trimws(x[6])
  } else {
    NA
  }
})

# Ensure sample names match and reorder metadata to match OTU table columns
otu_samples <- colnames(asv_mat)
meta_samples <- sample_metadata$sample_name
if (!all(otu_samples %in% meta_samples)) {
  stop("Sample names in OTU table do not match those in metadata. Please check your input files.")
}

# Reorder and subset metadata to match OTU table columns exactly
sample_metadata <- as.data.frame(sample_metadata[match(otu_samples, meta_samples), , drop=FALSE])
rownames(sample_metadata) <- otu_samples  # Set rownames to match OTU matrix columns

# Ensure OTU table columns are named with sample IDs
colnames(asv_mat) <- rownames(sample_metadata)
asv_mat <- as.matrix(asv_mat)
mode(asv_mat) <- "numeric"

# Final checks for sample name uniqueness and type before phyloseq object creation
if (any(duplicated(colnames(asv_mat)))) {
  stop("Duplicate sample names found in OTU table columns.")
}
if (any(duplicated(rownames(sample_metadata)))) {
  stop("Duplicate sample names found in metadata rownames.")
}
colnames(asv_mat) <- as.character(colnames(asv_mat))
#rownames(sample_metadata) <- as.character(rownames(sample_metadata))

# Create phyloseq object
OTU <- otu_table(asv_mat, taxa_are_rows=TRUE)
TAX <- tax_table(tax_matrix)
SAMPLES <- sample_data(sample_metadata)
physeq <- phyloseq(OTU, TAX, SAMPLES)

# Save phyloseq object for future use
saveRDS(physeq, file = file.path(output_dir, "physeq_object.rds"))

# Also save OTU table in BIOM format for interoperability
otu_biom <- make_biom(data=as(otu_table(physeq), "matrix"), 
                      observation_metadata=as.data.frame(tax_table(physeq)),
                      sample_metadata=as.data.frame(sample_data(physeq))
                      )
write_biom(otu_biom, biom_file = file.path(output_dir, "physeq_object.biom"))
```

## Analysis of taxon distribution and relative abundance

The amplicon data is filter at two key taxonomy levels to return taxon diversity in the project samples either at Genus or Species level. Note that the ASVs which did not reach this depth of classification are absent from the plots.

### Genus level results

The Genus classification results are used to produce a ASV count heatmap from the top 95% results (leaving out the 5% lowest count taxa). 

```{r genus level plot, echo=FALSE, fig.width=16, fig.height=6}
physeq_genus <- tax_glom(physeq, taxrank = "Genus")

# Taxa barplot (genus level, removing noise obtained by filter genus to keep 95% of total counts)
cutoff_gn <- 0.95
taxa_sums_vec_gn <- taxa_sums(physeq_genus)
total_counts_gn <- sum(taxa_sums_vec_gn)
sorted_taxa_gn <- sort(taxa_sums_vec_gn, decreasing = TRUE)
cumsum_taxa_gn <- cumsum(sorted_taxa_gn)
cutoff_index_gn <- which(cumsum_taxa_gn >= cutoff_gn * total_counts_gn)[1]
cutoff_value_gn <- sorted_taxa_gn[cutoff_index_gn]
physeq_genus_filtered <- prune_taxa(taxa_sums_vec_gn >= cutoff_value_gn, physeq_genus)

# Heatmap (filtered, no legend, genus level, ordered by similarity)
abund_mat_gn <- as(otu_table(physeq_genus_filtered), "matrix")
if(!taxa_are_rows(physeq_genus_filtered)) {
  abund_mat_gn <- t(abund_mat_gn)
}
# Get genus-level taxonomy labels for each OTU (show only Genus and parent Family)
get_genus_label <- function(tax_row) {
  fam <- ifelse(!is.na(tax_row[5]), tax_row[5], "") # Family
  gen <- ifelse(!is.na(tax_row[6]), tax_row[6], "") # Genus
  #paste(fam, gen, sep = "; ")
  return(gen)
}

genus_labels <- apply(as.matrix(tax_table(physeq_genus_filtered)), 1, get_genus_label)
rownames(abund_mat_gn) <- genus_labels

# Use sample labels for x-axis in heatmap
if ("label" %in% colnames(sample_metadata)) {
  colnames(abund_mat_gn) <- sample_metadata[colnames(abund_mat_gn), "label"]
}

# --- Add sample group annotation for heatmap ---
if ("smplgrp" %in% colnames(sample_metadata)) {
  sample_labels <- colnames(abund_mat_gn)
  # Map sample labels to sample_name
  sample_name_for_label <- setNames(rownames(sample_metadata), sample_metadata$label)
  # Get smplgrp for each sample label
  smplgrp_vec <- sample_metadata[sample_name_for_label[sample_labels], "smplgrp"]
  annotation_col <- data.frame(Group = smplgrp_vec)
  rownames(annotation_col) <- sample_labels
  # Set colors for groups
  group_levels <- unique(annotation_col$Group)
  group_colors <- setNames(viridis::viridis(length(group_levels)), group_levels)
  annotation_colors <- list(Group = group_colors)
} else {
  annotation_col <- NULL
  annotation_colors <- NULL
}

ha_col <- HeatmapAnnotation(
  Group = annotation_col$Group,
  col = list(Group = annotation_colors$Group),
  show_legend = TRUE,
  annotation_legend_param = list(
    nrow = 1, # Show legend as a single horizontal line
    title_gp = gpar(fontsize = 8),
    title = NULL,
    labels_gp = gpar(fontsize = 10)
  )
)

ht <- Heatmap(
  abund_mat_gn,
  name = NULL, # Suppress intensity legend
  col = viridis::viridis(100),
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_row_names = TRUE,
  show_column_names = TRUE,
  column_title = "Genus-level heatmap (ordered by similarity, ASV)",
  top_annotation = ha_col,
  row_names_gp = gpar(fontsize = 10),
  column_names_gp = gpar(fontsize = 7),
  show_heatmap_legend = FALSE
)

draw(ht, annotation_legend_side = "top")

pdf(file.path(output_dir, "genus_heatmap.pdf"), width = 16, height = 6)
draw(ht, annotation_legend_side = "top")
invisible(dev.off())
```

### Species level results

The Species classification results are used to produce a ASV count heatmap from the top 95% results (leaving out the 5% lowest count taxa). 

```{r species level plot, echo=FALSE, fig.width=16, fig.height=6}
physeq_species <- tax_glom(physeq, taxrank = "Species")

# Taxa barplot (genus level, removing noise obtained by filter genus to keep 95% of total counts)
cutoff_sp <- 0.95
taxa_sums_vec_sp <- taxa_sums(physeq_species)
total_counts_sp <- sum(taxa_sums_vec_sp)
sorted_taxa_sp <- sort(taxa_sums_vec_sp, decreasing = TRUE)
cumsum_taxa_sp <- cumsum(sorted_taxa_sp)
cutoff_index_sp <- which(cumsum_taxa_sp >= cutoff_sp * total_counts_sp)[1]
cutoff_value_sp <- sorted_taxa_sp[cutoff_index_sp]
physeq_species_filtered <- prune_taxa(taxa_sums_vec_sp >= cutoff_value_sp, physeq_species)

# Heatmap (filtered, no legend, genus level, ordered by similarity)
abund_mat_sp <- as(otu_table(physeq_species_filtered), "matrix")
if(!taxa_are_rows(physeq_species_filtered)) {
  abund_mat_sp <- t(abund_mat_sp)
}
# Get genus-level taxonomy labels for each OTU (show only Genus and parent Family)
get_species_label <- function(tax_row) {
  gen <- ifelse(!is.na(tax_row[6]), tax_row[6], "") # Genus
  spe <- ifelse(!is.na(tax_row[7]), tax_row[7], "") # Species
  #paste(gen, spe, sep = "; ")
  return(spe)
}

species_labels <- apply(as.matrix(tax_table(physeq_species_filtered)), 1, get_species_label)
rownames(abund_mat_sp) <- species_labels

# Use sample labels for x-axis in heatmap
if ("label" %in% colnames(sample_metadata)) {
  colnames(abund_mat_sp) <- sample_metadata[colnames(abund_mat_sp), "label"]
}

# --- Add sample group annotation for heatmap ---
if ("smplgrp" %in% colnames(sample_metadata)) {
  sample_labels <- colnames(abund_mat_sp)
  # Map sample labels to sample_name
  sample_name_for_label <- setNames(rownames(sample_metadata), sample_metadata$label)
  # Get smplgrp for each sample label
  smplgrp_vec <- sample_metadata[sample_name_for_label[sample_labels], "smplgrp"]
  annotation_col <- data.frame(Group = smplgrp_vec)
  rownames(annotation_col) <- sample_labels
  # Set colors for groups
  group_levels <- unique(annotation_col$Group)
  group_colors <- setNames(viridis::viridis(length(group_levels)), group_levels)
  annotation_colors <- list(Group = group_colors)
} else {
  annotation_col <- NULL
  annotation_colors <- NULL
}

ha_col <- HeatmapAnnotation(
  Group = annotation_col$Group,
  col = list(Group = annotation_colors$Group),
  show_legend = TRUE,
  annotation_legend_param = list(
    nrow = 1, # Show legend as a single horizontal line
    title_gp = gpar(fontsize = 8),
    title = NULL,
    labels_gp = gpar(fontsize = 10)
  )
)

ht <- Heatmap(
  abund_mat_sp,
  name = NULL, # Suppress intensity legend
  col = viridis::viridis(100),
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_row_names = TRUE,
  show_column_names = TRUE,
  column_title = "Species-level heatmap (ordered by similarity, ASV)",
  top_annotation = ha_col,
  row_names_gp = gpar(fontsize = 10),
  column_names_gp = gpar(fontsize = 7),
  show_heatmap_legend = FALSE
)

draw(ht, annotation_legend_side = "top")

pdf(file.path(output_dir, "species_heatmap.pdf"), width = 16, height = 6)
draw(ht, annotation_legend_side = "top")
invisible(dev.off())

```

### PCA plot

A variance analysis is made on the full based on taxonomy counts to identify subset of samples in the project with similar profiles and evaluate their coincidence with customer-defined groups.

```{r PCA plot, echo=FALSE}
# Ordination (PCoA)
ord <- ordinate(physeq, method="PCoA", distance="bray")
ordination_plot <- plot_ordination(physeq, ord, color=grouping_column)
ordination_plot

# Save ordination plot to PDF
ggsave(file.path(output_dir, "ordination_plot.pdf"), ordination_plot, width=7, height=5)
```

## Distribution of ITS amplicons lengths

```{r length distribution, echo=FALSE}

# Read sequences
seqs <- Biostrings::readDNAStringSet(ASV_sequences)
seq_lengths <- width(seqs)
asv_length_df <- tibble(ASV=names(seqs), Length=seq_lengths)

# Category 1: All ASVs
# Category 2: Classified at least to Phylum
classified_phylum_asvs <- rownames(tax_matrix)[apply(!is.na(tax_matrix[,1:2]) & tax_matrix[,1:2] != "", 1, all)]
classified_phylum_seqs <- seqs[names(seqs) %in% classified_phylum_asvs]
classified_phylum_lengths <- width(classified_phylum_seqs)
classified_phylum_length_df <- tibble(ASV=names(classified_phylum_seqs), Length=classified_phylum_lengths)

# Category 3: Classified to Genus
classified_genus_asvs <- rownames(tax_matrix)[!is.na(tax_matrix[,6]) & tax_matrix[,6] != ""]
classified_genus_seqs <- seqs[names(seqs) %in% classified_genus_asvs]
classified_genus_lengths <- width(classified_genus_seqs)
classified_genus_length_df <- tibble(ASV=names(classified_genus_seqs), Length=classified_genus_lengths)

# Overlay density plots
asv_length_plot_overlay <- ggplot() +
  geom_density(data=asv_length_df, aes(x=Length), color="black", size=1, adjust=1.2) +
  geom_density(data=classified_phylum_length_df, aes(x=Length), color="orange", size=1, adjust=1.2) +
  geom_density(data=classified_genus_length_df, aes(x=Length), color="blue", size=1, adjust=1.2) +
  labs(title="ASV Sequence Length Distribution\nblack: all, orange: classified to phylum, blue: classified to genus", x="Sequence Length (bp)", y="Density")

asv_length_plot_overlay

# Save overlay plot to PDF
ggsave(file.path(output_dir, "asv_length_histogram.pdf"), asv_length_plot_overlay, width=7, height=5)
```

## Tool and Data Versions

```{r tool_versions, results='asis', echo=FALSE}
cat("```\n")
cat(
  sapply(readLines(classification_info_file), function(x) {
    paste(sapply(strsplit(x, " ")[[1]], function(word) {
      if (grepl("/", word)) basename(word) else word
    }), collapse = " ")
  }),
  sep = "\n"
)
cat("```\n")
```

